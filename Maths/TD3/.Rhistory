plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"], pch = ".")
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"], pch = ".")
mtext(outer = TRUE, side = 3, "Lorenz model", cex = 1.5)
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m)))-u*B
dC = E1*((C0*l)/(1+h1*(x^m)))-u*C
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])
mtext(outer = TRUE, side = 3, "Circadian model", cex = 1.5)
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m)))-u*B
dC = E1*((C0*l)/(1+h1*(x^m)))-u*C
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m)))-u*B
dC = E1*((C0*l)/(1+h1*(x^m)))-u*C
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m)))-u*B
dC = E1*((C0*l)/(1+h1*(x^m)))-u*C
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
# return the rate of change
list(c(x, y, B ,C ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
x=x+dx
y=y+dy
B=B+dB
C=C+dC
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
x=x+dx
y=y+dy
B=B+dB
C=C+dC
# return the rate of change
list(c(x, y, B ,C ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
x=x+dx
y=y+dy
B=B+dB
C=C+dC
# return the rate of change
list(c(x, y, B ,C ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
x=x+dx
y=y+dy
B=B+dB
C=C+dC
# return the rate of change
list(c(x, y, B ,C ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C0-x)-b*x*(y+f)
dy = g*(B0-y)-((k1*y*(x^n))/((qu^n)+(x^n)))
dB = E1*((B0*l)/(1+h1*(x^m))-u*B)
dC = E1*((C0*l)/(1+h1*(x^m))-u*C)
x=x+dx
y=y+dy
B=B+dB
C=C+dC
# return the rate of change
list(c(x, y, B ,C ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])
library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C-x)-b*x*(y+f)
dy = g*(B-y)-k1*y*x^n/(qu^n+x^n)
dB = E1*(B*l/(1+h1*x^m)-u*B)
dC = E1*(C*l/(1+h1*x^m)-u*C)
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, 
g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C-x) - b*x*(y+f)
dy = g*(B-y)-k1*y*x^n/(qu^n+x^n)
dB = E1*(B*l / (1 + h1*x^m)-u*B)
dC = E1*(C*l / (1 + h1*x^m)-u*C)
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
plot(out[, "X"], out[, "Z"])library(deSolve)
parameters <- c(m=4, C0=2, B0=200, n=2, p=6.3, a=0.207, b=0.063, f=4, 
g=25.2, k1=630, qu=1.8, l=15,h1=1, u=6.3, E1=0.07)
# Codage de l'état du système (X, Y et Z) également sous forme de liste
# 
#
state <- c(x=0, y=0, B=200 ,C=2)
CiradianModel<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dx = p*a*(C -x) - b*x*(y+f)
dy = g*(B-y)-k1*y*x^n/(qu^n+x^n)
dB = E1*(B0*l / (1 + h1*x^m)-u*B)
dC = E1*(C0*l / (1 + h1*x^m)-u*C)
# return the rate of change
list(c(dx, dy, dB ,dC ))
})
# end with(as.list ...
}
# durée de la simulation (doit commencer par 0)
times <- seq(0, 120, by = 1)
# résolution du système et simulation
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
head(out)
par(oma = c(0, 0, 3, 0))
plot(out, xlab = "time", ylab = "-")
out <- ode(y = state, times = times, func = CiradianModel, parms = parameters)
metadata = read.table("gold.metadata.txt", sep="\t",header=TRUE); metadata
metadata = read.table("gold.metadata.txt", sep="\t",header=TRUE); metadata
U=iris
U
U.centered
centered(U)
?center
?centre
?centred
U=iris[,-5]
U
acp=princomp(U)
biplot(acp)
summary(acp)
?> summary(acp)
?princomp
acp.centered
apply(U,2,mean)
Uc=U-apply(U,2,mean)
U
Uc
cov(Uc)
Ucov=cov(Uc)
acp
eigen(Ucov)
vp=eigen(Ucov)
Ut=Uc%*%vp
boxplot(as.matrix(U) - U)
boxplot(as.matrix(U) - iris[,5])
boxplot(as.matrix(U) ~ iris[,5])
vp
Ut=Uc%*%vp$values[1,]
Ut=Uc%*%vp$values[,1]
Ut=Uc%*%vp$values[,1]
vp$values[,1]
vp$values
vp$values[1]
Ut=Uc%*%vp$values[1]
Ucov=cov(U)
Ucov
Ucov=(1/150)*t(Uc)*Uc
Uov
Ucov
Ucov=(1/150)*(t(Uc)%*%Uc)
U
Uc
class(Uc)
Ucov=(1/150)*(t(Uc)%*%Uc)
class(Uc)
as.matrix(Uc)
class(Uc)
U=as.matrix(Uc)
class(Uc)
U=iris[,-5]
Uc=as.matrix(Uc)
class(Uc)
Ucov=(1/150)*(t(Uc)%*%Uc)
Uov
Ucov
> vp=eigen(Ucov)
 vp=eigen(Ucov)
vp
vp$values
Ut=Uc%*%vp$values[1]
Ucov=cov(Uc)
 vp=eigen(Ucov)
vp$values
Ucov=cov(Uc)
head(Ucov)
Ucov2=(1/150)*(t(Uc)%*%Uc)
head(Ucov2)
Ucov2=(1/dim(Uc))*(t(Uc)%*%Uc)
head(Ucov2)
Uc1 = apply(U, 2, function(X) X-mean(X))
Uc2 = Uc=U-apply(U,2,mean) 
head(Uc1)
head(Uc2)
Uc+U1
Uc=U1
> class(Uc)
[1] "data.frame" #Il faut préciser à R que Uc est une matrice
> Uc=as.matrix(Uc)
> class(Uc)
[1] "matrix"
> Ucov=(1/150)*(t(Uc)%*%Uc) # ou Ucov=cov(Uc)
Uc=UC1
Uc=Uc1
Uc=UC
> class(Uc)
[1] "data.frame" #Il faut préciser à R que Uc est une matrice
> Uc=as.matrix(Uc)
> class(Uc)
[1] "matrix"
> Ucov=(1/150)*(t(Uc)%*%Uc) # ou Ucov=cov(Uc)
> Uc = apply(U, 2, function(X) X-mean(X)) #Centrer la matrice
> class(Uc)
[1] "data.frame" #Il faut préciser à R que Uc est une matrice
> Uc=as.matrix(Uc)
> class(Uc)
[1] "matrix"
> Ucov=(1/150)*(t(Uc)%*%Uc) # ou Ucov=cov(Uc)
class(Uc)
Ucov=(1/150)*(t(Uc)%*%Uc)
Ucov2=cov(Uc)
head(Ucov)
head(Ucov2)
vp=eigen(Ucov)
vp$values
X1 = Uc%*%vp$values[1]
vp$values/ sum(vp$values)
cumsum(vp$values)/ sum(vp$values)
> vp$values
acp=princomp(U)
acp
X1 = Uc%*%vp$values
1
X1 
vp$values
plot(acp$score[,1],acp$score[,2], pch=19, col=iris[,5])
UProj=Uc %*% vp$vectors
plot(UProj$score[,1],UProj$score[,2], pch=19, col=iris[,5])
plot(UProj[,1],score[,2], pch=19, col=iris[,5])
plot(UProj[,1],UProj[,2], pch=19, col=iris[,5])
plot(UProj[,1],UProj[,2], pch=5, col=iris[,5])
par(mfrow(c(1,2)))
par(mfrow=c(1,2))
